#!venv/bin/python3
from datetime import datetime as dt
import shellconfigparse as scp
import requests
import json
import os


# Load config into dict
config = scp.parse('/home/pi/OC-DigitalSignage/config.sh')

# Assign values from config
PI_ID = config['PI_ID']
PROJECTPATH = config['PROJECTPATH']
VIDEOPATH = config['VIDEOPATH']
BUCKETURL = config['BUCKETURL']
JSONPATH = config['JSONPATH']
FULLURL = f'{BUCKETURL}/{PI_ID}'


def fetch():
    """Downloads videos from AWS S3, given a list of videos
    """
    # Print separator for log
    print('* -------------------------------------------------------- *')

    # Print the date and time for the log
    print(f'* {dt.now()}')

    # Download videos.json from the server
    download_file(f'{JSONPATH}', 'videos.json')

    # Read the data from videos.json
    with open(JSONPATH, 'r') as f:
        data = f.read()
        data = json.loads(data)

        videos = []
        for entry in data:
            videos.append(entry)

    # Delete all videos that are not in videos.json
    for file in os.listdir(VIDEOPATH):
        if file not in videos and file.endswith('.mp4'):
            print(f'* Removing {file}...')
            os.remove(f'{VIDEOPATH}/{file}')

    # Download every video file from videos.json
    for video in videos:
        # Don't download if the file exists
        if os.path.exists(f'{VIDEOPATH}/{video}'):
            print(f'* {video} has already been downloaded.')
            pass
        else:
            print(f'* Downloading {video}...')
            download_file(f'{VIDEOPATH}/{video}', video)

    # Kill VLC before running the looper
    os.system('killall vlc')

    # Run the looper
    os.system(f'{PROJECTPATH}/looper')

    # Print debug information
    print(f'* Finished at {dt.now().strftime('%H:%M:%S')}')
    print('* Videos downloaded:')
    for video in videos:
        print(f'* {video}')

def download_file(file_path, file_name):
    """Downloads a file from the download link

    Args:
        file_path (string): path for the downloaded file
        file_name (string): the name of the file to be downloaded
    """
    response = requests.get(f'{FULLURL}/{file_name}')

    if response.status_code == 200:
        with open(file_path, 'wb') as local_file:
            for chunk in response.iter_content(chunk_size=128):
                local_file.write(chunk)
    else:
        print(f'* Unable to download\nStatus code: \
		{response.status_code}')
        quit()


if __name__ == '__main__':
    fetch()
