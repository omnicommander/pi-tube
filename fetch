#!venv/bin/python3
import shellconfigparse as scp
import requests
import json
import os


# Load config into dict
config = scp.parse('/home/pi/OC-DigitalSignage/config.sh')

# Assign values from config
PI_ID = config['PI_ID']
PROJECTPATH = config['PROJECTPATH']
VIDEOPATH = config['VIDEOPATH']
BUCKETURL = config['BUCKETURL']
JSONPATH = config['JSONPATH']
FULLURL = f'{BUCKETURL}/{PI_ID}'

def fetch():
    """Downloads videos from AWS S3, given a list of videos

    Args:
        debug (boolean): prints useful information for debugging
    """
    # Download videos.json from the server
    download_file(f'{JSONPATH}', 'videos.json')

    # Read the data from videos.json
    with open(JSONPATH, 'r') as f:
        data = f.read()
        data = json.loads(data)

        videos = []
        for entry in data:
            videos.append(entry)

    # Delete all videos that are not in videos.json
    for file in os.listdir(VIDEOPATH):
        if file not in videos and file.endswith('.mp4'):
            os.remove(f'{VIDEOPATH}/{file}')

    # Download every video file from videos.json
    for video in videos:
        # Don't download if the file exists
        if os.path.exists(f'{VIDEOPATH}/{video}'):
            print(f'{video} has already been downloaded.\n')
            pass
        else:
            download_file(f'{VIDEOPATH}/{video}', video)
            print(f'\nDownloading {video}...\n')

    # Run the looper
    os.system(f'{PROJECTPATH}/looper')

    # Print debug information
    print('\nFinished!\n')
    print('Videos downloaded:')
    for video in videos:
        print(video)
    print('\n')


def download_file(file_path, file_name):
    """Downloads a file from the download link

    Args:
        file_path (string): path for the downloaded file
        file_name (string): the name of the file to be downloaded
    """
    response = requests.get(f'{FULLURL}/{file_name}')

    if response.status_code == 200:
        with open(file_path, 'wb') as local_file:
            for chunk in response.iter_content(chunk_size=128):
                local_file.write(chunk)
    else:
        print(f'\nUnable to download\nStatus code: \
		{response.status_code}\n')
        quit()


if __name__ == '__main__':
    fetch()
